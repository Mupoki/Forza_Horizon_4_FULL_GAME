<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" href="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQye1ZI8w4zQI51HtbujoJSlE_Y1KptmBvRKw&s">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forza Horizon 4</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,900&display=swap" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background: #000;
            user-select: none;
        }

        /* --- FH4 HUD STYLES --- */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Speedometer Container */
        .speedometer-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 220px;
            height: 220px;
        }

        .speed-circle {
            position: relative;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            border: 4px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        .speed-text {
            color: #FFF;
            font-size: 56px;
            font-weight: 900;
            font-style: italic;
            line-height: 1;
        }

        .speed-text .unit {
            font-size: 16px;
            font-weight: 400;
            color: #AAA;
            display: block;
            text-align: center;
            margin-top: -5px;
        }

        .gear-text {
            position: absolute;
            bottom: 45px;
            font-size: 20px;
            color: #F75F21;
            font-weight: 900;
            border: 2px solid #FFF;
            width: 30px;
            height: 30px;
            line-height: 28px;
            text-align: center;
            border-radius: 50%;
            background: #222;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
        }

        /* RPM Bar */
        .rpm-bar-bg {
            position: absolute;
            bottom: 85px;
            width: 160px;
            height: 8px;
            background: #444;
            border-radius: 4px;
            overflow: hidden;
            transform: rotate(-10deg);
        }

        .rpm-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(to right, #0AB193, #F75F21);
            transition: width 0.1s;
        }

        /* Skill Score */
        .score-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .skill-text {
            color: #F75F21;
            font-weight: 900;
            font-size: 24px;
            font-style: italic;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
            opacity: 0;
            transition: opacity 0.3s;
            transition: transform 0.1s;
        }

        .skill-score {
            color: #FFF;
            font-weight: 900;
            font-size: 42px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }

        /* Controls Hint */
        .controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
        }
    </style>
</head>
<body>

    <!-- FH4 HUD -->
    <div class="ui-layer">
        <div class="score-container">
            <div class="skill-text" id="skill-action">ULTIMATE DRIFT</div>
            <div class="skill-score" id="score">0</div>
        </div>

        <div class="speedometer-container">
            <div class="speed-circle">
                <div class="speed-text">
                    <span id="speed">0</span>
                    <span class="unit">KM/H</span>
                </div>
                <div class="rpm-bar-bg">
                    <div class="rpm-bar" id="rpm"></div>
                </div>
                <div class="gear-text" id="gear">1</div>
            </div>
        </div>

        <div class="controls-hint">
            WASD to Drive â€¢ Hold Turn to Drift
        </div>
    </div>

    <script>
    /* =========================
       1. Setup & Scene
    ========================= */
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 500);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 6000);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', ()=>{
        camera.aspect=innerWidth/innerHeight; 
        camera.updateProjectionMatrix(); 
        renderer.setSize(innerWidth,innerHeight);
    });

    // Lighting
    const sun = new THREE.DirectionalLight(0xffffff, 1.2); 
    sun.position.set(100, 200, 100); 
    sun.castShadow = true; 
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 500;
    const d = 300;
    sun.shadow.camera.left = -d; sun.shadow.camera.right = d;
    sun.shadow.camera.top = d; sun.shadow.camera.bottom = -d;
    scene.add(sun); 

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    scene.add(hemiLight);

    /* =========================
       2. Procedural Textures
    ========================= */
    function repeatTex(draw,w=256,h=256,rx=1,ry=1){
      const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); draw(ctx,w,h);
      const t=new THREE.CanvasTexture(c); t.wrapS=t.wrapT=THREE.RepeatWrapping; t.repeat.set(rx,ry); t.anisotropy=8; return t;
    }
    const grassTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#2b8a3e';ctx.fillRect(0,0,w,h);for(let i=0;i<1200;i++){ctx.fillStyle=`rgb(20,${80+Math.random()*80|0},20)`;ctx.fillRect(Math.random()*w,Math.random()*h,1,1);}},256,256,64,64);
    const asphaltTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#2e2e2e';ctx.fillRect(0,0,w,h);ctx.fillStyle='#3a3a3a';for(let i=0;i<900;i++){ctx.fillRect(Math.random()*w,Math.random()*h,1,1);}},256,256,1,48);
    const laneTex = repeatTex((ctx,w,h)=>{ctx.clearRect(0,0,w,h);ctx.fillStyle='#fff';for(let y=0;y<h;y+=64){ctx.fillRect(w/2-4,y,8,32)}},256,256,1,48);
    const sidewalkTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#b8b8b8';ctx.fillRect(0,0,w,h);ctx.strokeStyle='#a0a0a0';for(let x=0;x<w;x+=32){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}for(let y=0;y<h;y+=24){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}},256,256,16,16);
    const windowsTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#141418';ctx.fillRect(0,0,w,h);for(let y=8;y<h;y+=18){for(let x=8;x<w;x+=18){const on=Math.random()>.35;ctx.fillStyle=on?'#aee1ff':'#0d0d18';ctx.fillRect(x,y,12,12);ctx.fillStyle='rgba(255,255,255,.06)';ctx.fillRect(x,y,12,6);}}},256,256,4,4);
    const brickTex = repeatTex((ctx,w,h)=>{ctx.fillStyle='#8a4b2a';ctx.fillRect(0,0,w,h);ctx.fillStyle='#a96642';const bh=18,bw=36;for(let y=0;y<h;y+=bh){const off=(y/bh)%2?bw/2:0;for(let x=-off;x<w;x+=bw){ctx.fillRect(x,y,bw-2,bh-2)}}ctx.strokeStyle='rgba(0,0,0,.2)';for(let y=0;y<h;y+=bh){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke()}for(let x=0;x<w;x+=bw){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke()}},256,256,4,4);

    /* =========================
       3. World Generation & Collision Setup
    ========================= */
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(5000,5000), new THREE.MeshLambertMaterial({map:grassTex}));
    ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground);

    const ROAD_W=18, SIDEWALK_W=6, BLOCK=130, GRID=7, half=Math.floor(GRID/2);
    const city = new THREE.Group(); scene.add(city);
    const colliders = [];

    function roadStrip(x,z,len,dir='z'){
      const g=new THREE.Group();
      const asphalt=new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W,len), new THREE.MeshLambertMaterial({map:asphaltTex}));
      asphalt.rotation.x=-Math.PI/2; asphalt.receiveShadow=true; g.add(asphalt);
      const lanes=new THREE.Mesh(new THREE.PlaneGeometry(2,len), new THREE.MeshBasicMaterial({map:laneTex,transparent:true}));
      lanes.rotation.x=-Math.PI/2; lanes.position.y=0.01; g.add(lanes);
      const swL=new THREE.Mesh(new THREE.PlaneGeometry(SIDEWALK_W,len), new THREE.MeshLambertMaterial({map:sidewalkTex}));
      swL.rotation.x=-Math.PI/2; swL.position.set(-ROAD_W/2-SIDEWALK_W/2,0.02,0); g.add(swL);
      const swR=swL.clone(); swR.position.x=+ROAD_W/2+SIDEWALK_W/2; g.add(swR);
      if(dir==='x') g.rotation.y=Math.PI/2;
      g.position.set(x,0,z); city.add(g);
    }
    for(let i=-half;i<=half;i++){ roadStrip(i*BLOCK,0,GRID*BLOCK,'z'); roadStrip(0,i*BLOCK,GRID*BLOCK,'x'); }

    const structures = new THREE.Group(); city.add(structures);

    function makeBuilding(x,z){
      const h=40+Math.random()*140;
      const mat=new THREE.MeshLambertMaterial({map: Math.random()>.4? windowsTex : brickTex});
      const b=new THREE.Mesh(new THREE.BoxGeometry(42,h,42),mat); 
      b.position.set(x,h/2,z); 
      b.castShadow=true; b.receiveShadow=true; 
      b.geometry.computeBoundingBox();
      const box = new THREE.Box3().setFromObject(b);
      colliders.push(box);
      return b;
    }

    function makeHouse(x,z){
      const body=new THREE.Mesh(new THREE.BoxGeometry(38,18,28), new THREE.MeshLambertMaterial({map:brickTex}));
      body.position.set(x,9,z); body.castShadow=true; body.receiveShadow=true;
      body.geometry.computeBoundingBox();
      const box = new THREE.Box3().setFromObject(body);
      colliders.push(box);

      const win=new THREE.Mesh(new THREE.BoxGeometry(36,1,0.5), new THREE.MeshBasicMaterial({map:windowsTex}));
      const w1=win.clone(); w1.position.set(x,13,z-14.5);
      const w2=win.clone(); w2.position.set(x,8,z-14.5);
      const door=new THREE.Mesh(new THREE.BoxGeometry(3,6,0.6), new THREE.MeshLambertMaterial({color:0x6b4a2f}));
      door.position.set(x-8,3.2,z+14.6);
      const roof=new THREE.Mesh(new THREE.ConeGeometry(28,10,4), new THREE.MeshLambertMaterial({color:0x5a4633}));
      roof.position.set(x,23,z); roof.rotation.y=Math.PI/4; roof.castShadow=true;
      const g=new THREE.Group(); g.add(body,w1,w2,door,roof); return g;
    }

    for(let gx=-half; gx<=half; gx++){
      for(let gz=-half; gz<=half; gz++){
        const wx=gx*BLOCK, wz=gz*BLOCK;
        if(Math.random()>.5){
          structures.add(makeHouse(wx+44,wz+44));
          structures.add(makeHouse(wx-44,wz-44));
        }else{
          structures.add(makeBuilding(wx+44,wz+44));
          structures.add(makeBuilding(wx-44,wz-44));
        }
        structures.add(makeBuilding(wx+44,wz-44));
        structures.add(makeBuilding(wx-44,wz+44));
      }
    }

    /* =========================
       4. Car & Particles
    ========================= */
    function detailedCar(color=0xd92525){
      // Physics Container
      const car = new THREE.Group();
      
      // Visual Container (For Drift Tilt/Rotation)
      const visual = new THREE.Group();
      car.add(visual);

      const body=new THREE.Mesh(new THREE.BoxGeometry(4.6,1.2,9.2), new THREE.MeshPhongMaterial({color: color, shininess:150, specular:0x555555}));
      body.position.y=1.4; body.castShadow=true; visual.add(body);
      
      const cabin=new THREE.Mesh(new THREE.BoxGeometry(3.6,1.0,3.5), new THREE.MeshPhongMaterial({color:0x111111, shininess:200}));
      cabin.position.y=2.3; cabin.position.z=-0.5; visual.add(cabin);
      
      const spoiler=new THREE.Mesh(new THREE.BoxGeometry(4.6,0.2,1.0), new THREE.MeshPhongMaterial({color:color}));
      spoiler.position.set(0,2.2,4.4); visual.add(spoiler);

      function wheel(){const g=new THREE.Group();
        const tire=new THREE.Mesh(new THREE.CylinderGeometry(1.05,1.05,0.7,24), new THREE.MeshLambertMaterial({color:0x141414}));
        tire.rotation.z=Math.PI/2; tire.castShadow=true; g.add(tire); return g;}
      
      const wFL=wheel(),wFR=wheel(),wRL=wheel(),wRR=wheel();
      wFL.position.set(-2.1,0.9,-3); wFR.position.set(2.1,0.9,-3); 
      wRL.position.set(-2.1,0.9,3); wRR.position.set(2.1,0.9,3);
      visual.add(wFL,wFR,wRL,wRR); 
      
      // Store references for animation
      car.userData.visual = visual;
      car.userData.wheels = {wFL,wFR,wRL,wRR};
      return car;
    }
    const playerCar = detailedCar(); 
    scene.add(playerCar); 
    playerCar.position.set(0,0,20);

    // Particle System (Smoke)
    const smokeParticles = [];
    const smokeGeo = new THREE.PlaneGeometry(1, 1);
    const smokeMat = new THREE.MeshBasicMaterial({color:0xcccccc, transparent:true, opacity:0.6});
    
    function spawnSmoke(x, y, z) {
        const p = new THREE.Mesh(smokeGeo, smokeMat);
        p.position.set(x, y, z);
        p.rotation.x = -Math.PI/2; // Flat on ground
        p.rotation.z = Math.random() * Math.PI;
        p.scale.set(0.5, 0.5, 0.5);
        scene.add(p);
        smokeParticles.push({ mesh: p, life: 1.0 });
    }

    function updateSmoke() {
        for(let i=smokeParticles.length-1; i>=0; i--){
            const p = smokeParticles[i];
            p.life -= 0.02; // Fade speed
            p.mesh.position.y += 0.05; // Rise
            p.mesh.scale.multiplyScalar(1.05); // Expand
            p.mesh.material.opacity = p.life * 0.5;
            p.mesh.rotation.z += 0.05;

            if(p.life <= 0) {
                scene.remove(p.mesh);
                smokeParticles.splice(i, 1);
            }
        }
    }

    /* =========================
       5. Physics & Logic
    ========================= */
    const keys={};
    addEventListener('keydown', e => { keys[e.code] = true; });
    addEventListener('keyup', e => { keys[e.code] = false; });

    let carSpeed=0, carAngle=Math.PI;
    const accel=0.08, brake=0.2, maxSpeed=3.8, friction=0.985, turnRate=0.045;
    let score = 0;
    
    // Drift Physics Vars
    let driftFactor = 0; // How much "sideways" visual angle
    let bodyRoll = 0; // Body tilt

    function getNextPosition(obj, angle, dist) {
        return {
            x: obj.position.x + Math.sin(angle) * dist,
            z: obj.position.z + Math.cos(angle) * dist
        };
    }

    function checkCollision(nextX, nextZ) {
        const testBox = new THREE.Box3();
        testBox.min.set(nextX - 2, 0, nextZ - 2);
        testBox.max.set(nextX + 2, 5, nextZ + 2);

        for (let i = 0; i < colliders.length; i++) {
            if (testBox.intersectsBox(colliders[i])) return true;
        }
        return false;
    }

    function wrapCity(obj){ 
        const lim=half*BLOCK+30; 
        if(obj.position.x>lim) obj.position.x=-lim; 
        if(obj.position.x<-lim) obj.position.x=lim; 
        if(obj.position.z>lim) obj.position.z=-lim; 
        if(obj.position.z<-lim) obj.position.z=lim; 
    }

    window.focus();
    document.body.addEventListener('click', () => window.focus());

    /* =========================
       6. Animation Loop
    ========================= */
    function animate(){
      requestAnimationFrame(animate);

      // Input
      const forward = keys['ArrowUp'] || keys['KeyW'];
      const back    = keys['ArrowDown'] || keys['KeyS'];
      const left    = keys['ArrowLeft'] || keys['KeyA'];
      const right   = keys['ArrowRight'] || keys['KeyD'];

      // --- Physics ---
      if(forward) carSpeed += accel;
      else if(back) carSpeed -= brake * 0.5;
      else carSpeed *= friction;
      
      carSpeed = Math.max(-maxSpeed/2, Math.min(maxSpeed, carSpeed));
      
      const isMoving = Math.abs(carSpeed) > 0.05;
      const isDrifting = Math.abs(carSpeed) > 1.2 && (left || right);

      if(isMoving){
          // Steering
          if(left)  carAngle += turnRate;
          if(right) carAngle -= turnRate;
          
          // --- DRIFT LOGIC ---
          // 1. Calculate Target Slip Angle (Visual rotation)
          let targetDrift = 0;
          if(isDrifting) {
              // If turning left, body rotates slightly MORE left (slip angle)
              targetDrift = left ? 0.35 : -0.35;
              
              // 2. Score
              score += 12;
              document.getElementById('score').innerText = score.toLocaleString();
              document.getElementById('skill-action').style.opacity = 1;
              document.getElementById('skill-action').style.transform = `scale(${1 + Math.random()*0.1})`;

              // 3. Smoke Particles (Rear wheels)
              if(Math.random() > 0.5) {
                // Approximate rear wheel positions based on car position and angle
                const rx = playerCar.position.x - Math.sin(carAngle)*3;
                const rz = playerCar.position.z - Math.cos(carAngle)*3;
                // Add a little width offset
                spawnSmoke(rx + Math.random(), 0.2, rz + Math.random());
              }

          } else {
              document.getElementById('skill-action').style.opacity = 0;
              document.getElementById('skill-action').style.transform = 'scale(1)';
          }

          // Smoothly interpolate drift visual
          driftFactor += (targetDrift - driftFactor) * 0.1;

          // 4. Body Roll (Centrifugal force tilt)
          // Turning left -> Roll right
          let targetRoll = 0;
          if(left) targetRoll = -0.15 * (carSpeed/maxSpeed);
          if(right) targetRoll = 0.15 * (carSpeed/maxSpeed);
          bodyRoll += (targetRoll - bodyRoll) * 0.1;

      } else {
          driftFactor *= 0.9;
          bodyRoll *= 0.9;
      }

      updateSmoke();

      // --- Collision & Movement ---
      const nextPos = getNextPosition(playerCar, carAngle, carSpeed);
      if (checkCollision(nextPos.x, nextPos.z)) {
          carSpeed = -carSpeed * 0.5; // Bounce
      } else {
          playerCar.position.x = nextPos.x;
          playerCar.position.z = nextPos.z;
      }

      // Apply Rotations
      // Actual Physics Rotation
      playerCar.rotation.y = carAngle; 
      // Visual Drift Rotation (Slip Angle)
      playerCar.userData.visual.rotation.y = driftFactor; 
      // Visual Body Roll
      playerCar.userData.visual.rotation.z = bodyRoll;

      wrapCity(playerCar);

      // Camera Follow
      // Add slight lag to camera angle for dynamic feel
      const camDist = 18;
      const camHeight = 8;
      // We follow the car's physics angle, not the drift angle, to keep view steady
      camera.position.x = playerCar.position.x - Math.sin(carAngle) * camDist;
      camera.position.z = playerCar.position.z - Math.cos(carAngle) * camDist;
      camera.position.y = playerCar.position.y + camHeight;
      camera.lookAt(playerCar.position.x, playerCar.position.y + 2, playerCar.position.z);
      
      // Wheel Animation
      const w=playerCar.userData.wheels;
      if(w) { 
          const spin = carSpeed;
          w.wFL.rotation.x+=spin; w.wFR.rotation.x+=spin; 
          w.wRL.rotation.x+=spin; w.wRR.rotation.x+=spin; 
          // Front wheel steering visuals
          let steerAngle = 0;
          if(left) steerAngle = 0.3;
          if(right) steerAngle = -0.3;
          // Counter-steer logic during drift!
          if(Math.abs(driftFactor) > 0.1) steerAngle = -steerAngle; 
          
          w.wFL.rotation.y = steerAngle; 
          w.wFR.rotation.y = steerAngle;
      }

      // UI
      const kmh = Math.abs(carSpeed * 80).toFixed(0);
      document.getElementById('speed').innerText = kmh;
      const rpmPct = Math.min((Math.abs(carSpeed) / maxSpeed) * 100, 100);
      document.getElementById('rpm').style.width = rpmPct + "%";
      
      let gear = 1;
      if(kmh > 60) gear = 2;
      if(kmh > 120) gear = 3;
      if(kmh > 190) gear = 4;
      if(kmh > 240) gear = 5;
      if(kmh === "0") gear = "N";
      if(carSpeed < 0) gear = "R";
      document.getElementById('gear').innerText = gear;

      renderer.render(scene,camera);
    }
    animate();

    </script>
</body>
</html>
